import requests
import base64
import pandas
import time
from datetime import datetime, timedelta, timezone


if 'data_loader' not in globals():
    from mage_ai.data_preparation.decorators import data_loader
if 'test' not in globals():
    from mage_ai.data_preparation.decorators import test
from mage_ai.data_preparation.shared.secrets import get_secret_value

def _get_access_token():
    refresh_token = get_secret_value('qb_refresh_token')
    client_secret = get_secret_value('qb_client_secret')
    client_id = get_secret_value('qb_client_id')
    url = 'https://oauth.platform.intuit.com/oauth2/v1/tokens/bearer'
    auth_header = base64.b64encode(f"{client_id}:{client_secret}".encode()).decode()
    headers = {
    "Accept": "application/json",
    "Authorization": f"Basic {auth_header}",
    "Content-Type": "application/x-www-form-urlencoded"
    }
    data = {
        "grant_type": "refresh_token",
        "refresh_token": refresh_token
    }
    response = requests.post(url, headers=headers, data=data)
    if response.status_code == 200:
        tokens = response.json()
        print(f"New token")
        return tokens["access_token"]
    else:
        print("Error:", response.json())

# Funcion anonima para que no aparezca
def _fetch_qb_data(realm_id,access_token, query, base_url, minor_version):
    if not base_url or not minor_version:
        raise ValueError("Se requiere una URL base y el minor version")

    headers = {
        'Authorization': f'Bearer {access_token}',
        'Accept': 'application/json',
        'Content-Type': 'text/plain'
    }

    params = {
        'query': query,
        'minorversion': minor_version
    }

    url = f"{base_url.rstrip('/')}/v3/company/{realm_id}/query"
    max_retries = 5
    for i in range(max_retries):
        try:
            #print(f'Request a la API: {base_url} \n {headers} \n {params}')
            print(f'Request a la API, intento {i+1}')
            response = requests.get(url, headers=headers, params=params, timeout=60**(i+1))
            response.raise_for_status()
            data = response.json()
            print('Datos recibidos de la API correctamente')
            return data
        except requests.exceptions.RequestException as e:
            print(f'Error en la pull de la API: {e}')
            print(f"Reintentando, intento {i + 2}...")
    raise Exception(f"No se pudo obtener la data después de {max_retries} reintentos.")
    





@data_loader
def load_data(*args, **kwargs):
    """
    Template code for loading data from any source.

    Returns:
        Anything (e.g. data frame, dictionary, array, int, str, etc.)
    """
    # Poner fechas de inicio y fin
    fecha_inicio = kwargs['fecha_inicio']
    fecha_fin = kwargs['fecha_fin']

    # Convertir strings a datetime
    start_date = datetime.fromisoformat(fecha_inicio).astimezone(timezone.utc)
    end_date = datetime.fromisoformat(fecha_fin).astimezone(timezone.utc)

    
    realm_id = get_secret_value('qb_realm_id')
    access_token = _get_access_token()
    minor_version = 75
    # query = 'select * from Invoice'
    base_url = 'https://sandbox-quickbooks.api.intuit.com'
    all_items = []
    current_start = start_date
    # Se quita 1 segundo para que no se pase al otro dia
    current_end = min(current_start + timedelta(days=1) - timedelta(seconds=1), end_date)  # tramo diario
    print(f"Procesando: {current_start.date()} a {current_end.date()}")
    start_time = time.time()
    pages_read = 0
    rows_act = 0
    page_size = 100 # Detener cuando este incompleto
    start_pos = 1
    while True:
        try:
            utc_start = datetime.now(timezone.utc)
            # No se puede filtar por fecha directamente porque solo existen fechas en MetaData
            query = (f"select * from Item "
                    f"startposition {start_pos} maxresults {page_size}")

            response = _fetch_qb_data(realm_id, access_token, query, base_url, minor_version)
            items_page = response.get('QueryResponse', {}).get('Item', [])
            if not items_page:
                print(f"No se encontraron datos en el")
                break
            print(f"Procesando pagina {pages_read+1}")

            #Tenemos que acceder a MetaData para accerder a una fecha y filtar los Items
            filtered_items = []
            for item in items_page:
                create_time_str = item.get("MetaData", {}).get("CreateTime", "")
                if create_time_str:
                    # Convertir la fecha de CreateTime a un objeto datetime
                    create_time = datetime.strptime(create_time_str, "%Y-%m-%dT%H:%M:%S%z")
                    # Comprobar si la fecha de CreateTime está dentro del rango
                    if start_date <= create_time <= end_date:
                        filtered_items.append(item)
            utc_end = datetime.now(timezone.utc)


            pages_read += 1
            rows_act += len(items_page)            
            # METADATOS
            for item in filtered_items:
                all_items.append({
                    'id': item['Id'],
                    'item': item,
                    'ingested_at_utc': datetime.utcnow(),
                    'extract_window_start_utc': utc_start,
                    'extract_window_end_utc': utc_end,
                    'page_number': len(items_page),
                    'request_item': query
                })
            
            if len(items_page) < page_size:
                break  # última página del tramo
            start_pos += page_size
        except Exception as e:
            print(f"Error al procesar la página {start_pos}: {e}")
            break
    duration = time.time() - start_time
    # print logs
    print(f'Finalizado: {rows_act} filas en {round(duration, 2)}s, {pages_read} páginas')

    df = pandas.DataFrame(all_items)
    if all_items:
        print(f"Total filas cargadas: {len(df)}")
        return df
    else:
        print("No se encontraron invoices en el rango indicado.")
        return pandas.DataFrame()

    

@test
def test_output(output, *args) -> None:
    """
    Template code for testing the output of the block.
    """
    assert output is not None, 'The output is undefined'
